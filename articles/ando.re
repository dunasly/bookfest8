
= C++ の初心者がソースコードを触る前にまず理解して欲しいこと

== 前提条件
本章を読んでいただく為の前提条件を示します。

・JavaやC#などのプログラムを組んだことがあるが、C++言語のプログラムをあまり知らない方（必須）

・C++言語をこれから勉強したい人 (本章の内容を注意しながら勉強してほしい)

・C++11/14を知らない人(一読してほしい)

== 目的
C++言語はメモリの操作を行います。
メモリの操作を誤るとメモリリークやクラッシュが頻繁に発生してしまいます。
C++以降の言語しか触ったことのない技術者はメモリ操作の重要性を理解できていない方が多いので注意を促すと共にメモリ操作の処理を中心に紹介します。

※本章は初心者でも理解できる様に詳細な説明を省いています。

※C++言語はC言語と共有部分も多いので、C言語の内容も多く含まれています。

== 事前知識
=== プログラミング言語の歴史
C++言語は歴史の古い言語です。
C#やJavaなどはC++言語を改良、発展させた言語と言っても過言では有りません。
従って、C#やJavaなどでは当たり前なのにC++言語では存在しないことが多々有ります。
それは古い言語なんだから仕方のないことだと思って諦めてください。

=== 動作環境の違い
では、なぜ古いC++言語を使うのでしょう？
1番の要因は処理スピードかと思います。
そのスピード差を産む要因は動作環境の違いにあります。
以下の図のように、C++のアプリはOSの上で直接動き、メモリなどを操作します。
一方、JavaやC#のアプリはミドルウェアを介して動作します。

//indepimage[ando_1]

ミドルウェアを介すと言うことは、その分のプログラムを経由して動作しなければなりません。
例えばプログラムで変数を1つ作り、値の代入するなどの当たり前の動作でもミドルウェアを介す処理がどれだけあるでしょう。
これが処理スピードの差になります。@<br>{}
近年ではHDDの大容量化やCPUの処理スピード/メモリへのアクセススピードの向上と言ったハード面での性能アップもあり、
ミドルウェアを介す言語のアプリでも十分な処理スピードが得られています。

しかし、C++のアプリが処理スピードで負ける訳がありません。
C++言語をきちんと理解し、メモリ管理をして、最速のアプリを目指しましょう。

== 最重要確認事項
=== new / delete
C++言語を触る上で@<br>{}
　@<b>{new と delete} (もしくはC言語のmalloc / free)@<br>{}
の意味がわからない方はC++言語を勉強し直し、必ず理解してください。
new/deleteはメモリ確保/解放処理そのものです。@<br>{}
C++以降の言語ではnewは使用しますが、deleteは使用しませんので
deleteを知らないという方は特に注意が必要です。
deleteを知らない方がメモリーリークを発生させるコードをよく書きます。
=== デストラクタについて
deleteをコールしたとき、あるいはスタックからインスタンスが削除されるときに呼ばれるメソッドがデストラクタになります。
クラスに記述しないと暗黙的デストラクタが自動的に用意されるのですが（C++11)、デストラクタとしくじると、メモリリーク、リソースリークを引き起こすので明示的に記述する習慣をつけてください。
注意する項目を箇条書きします。@<br>{}

・継承される可能性があるクラスのデストラクタは必ずvirtual宣言をする。
//cmd{
    virtual ~Hoge();
//}
　　- virtualを記述しないとで基底クラス（スーパークラス）のデストラクタを呼んでも、継承先のクラス（サブクラス）のデストラクタがコールされず、リークが発生する恐れがある。@<br>{}
　　- 仮想関数を持つクラスと持たないクラスのサイズ差がたかだか4(or 8)バイトなので、基本的に付ける方針で問題ないと思う。@<br>{}
@<br>{}
・中身が空のデストラクタを実装するのがイヤなら、ヘッダーに次のように記述する。
//cmd{
    virtual ~Hoge()=default;
//}
　　- コンパイラが自動的に処理してくれるので、ビルド速度もあがって良い感じ。（C++11から）@<br>{}
@<br>{}
@<br>{}
・デストラクタ内で記述してよいのは下記のとおり。仕様上はなんでも記述できるが、デバッグが死ぬほど大変になるので、ルールとして心がけておく@<br>{}
　　- メンバ変数（ポインタ）のdelete@<br>{}
　　- リソース（テクスチャはモデルなど）の解放処理@<br>{}
　　- クリティカルセクションのunlock@<br>{}
　　- スレッドや非同期処理の停止@<br>{}

=== ポインタ(*)について
C/C++言語を触る上で必ず通る道がポインタです。
ポインタを理解せずにC++言語のソースコードは書けません。
ポインタも重要ですので、わかっていない方は必ず理解してください。
一般の書籍やWebで十分に調べられます。@<br>{}
ポインタを理解した上で、以降を読む際に押さえて欲しいことは以下の内容です。@<br>{}

・ポインタ変数は4バイト(64bit環境では8バイト）※サイズはsizeof(int*)等で調べられます。


== 基礎知識
=== 参照(&)について
参照は身に付けておくべき項目です。
(個人的見解ですが、)C++以降の言語の変数は実際は参照となっています。
他の言語を理解する上でも覚えておくと良いでしょう。

== 関数の引数について
関数の引数には主に以下の3つの渡し方があります。

・値渡し

・ポインタ渡し

・参照渡し

==== 値(コピー)渡し
値渡しは、変数(＝オブジェクト)をコピーして渡すということです。
//cmd{
void functionA(int i, string str, myClass myc) {
    ・・・
}
//}
他にも重要なことはありますが、そちらは自身で調べてください。
ここでは”コピーする”と言うことを理解してください。
intやfloatなどサイズが小さいものに関しては問題ないのですが、classやstructを値渡しすることはやめてください。
例えば、以下のようなクラスを値渡しすると80バイトものメモリがもう一つ確保され、そのメモリに対して値を設定する処理が発生します。
//cmd{
class largeSizeClass {
    int a, b, c, d, e;    // 4バイト×5
    float f, g, h, i, j;    // 4バイト×5
    double k, l, m, n, o;    // 8バイト×5
}
//}
これが増えていくと、アプリのメモリを圧迫し、処理速度も遅くなります。
値渡しが多いソースコードはこの処理を改善することをオススメします。

==== ポインタ渡し
ポインタ渡しは名前の通りポインタを渡します。
//cmd{
void functionB(int i, string* str, myClass* myc) {
    *str = "ABC";   // 値を変更できます。
　　　　myc->hour = 1;  // 値を変更できます。
    ・・・
}
//}
上記した通り、ポインタ変数のサイズは4 or 8バイトで、アドレスの先の実体は変わりません。
従って、値渡しに比べて処理が高速化されます。
しかし、値渡しと違い関数の中でアドレスの先の実体を操作する事が可能です。
関数の中で値を変えてしまい、呼び出し元でその事を理解せずに値が変わっていないつもりのまま処理し、不具合が発生するケースがよくあります。
注意してください。

==== 参照渡し
参照渡しはほぼポインタ渡しと同様です。
注意点もポインタ渡しと同様ですが、
参照渡しした変数(クラス)の値を変更すると、ソースコードの混乱を招きます。参照渡しの際の関数内での値変更は行わないようにしてください。
//cmd{
void functionC(int i, string& str, myClass& myc) {
　　　　str = "ABC";    // 可能ですが、使用しないでください。
　　　　myc.hour = 1;  // 可能ですが、使用しないでください。
    ・・・
}
//}

==== 参照渡しのconst付与について
ポインタ渡しと参照渡しはほぼ同様であると上記しましたが、一体どちらを使用した方が良いでしょうか？
上述の注意点と可読性を考慮して以下のように使い分けると良いです。

・ポインタ渡し -> 関数内で変更する場合

・参照渡し -> 関数内で変更しない場合
@<br>{}
@<br>{}
この際の参照渡しには必ずconstを付与してください。constを付与することにより操作性、可読性が格段に上がります。
//cmd{
void functionD(int i, string* str, const myClass& myc) {
    ・・・
    str->replace(1, "morning", "noon");
    int hour = myc.hour;
　　　　// myc.hour = 1;   // コンパイルエラーとなります。
    ・・・
}
//}

== 応用知識
=== 変数の初期値について
以下のようなコードがあります。
//cmd{
  int a;
  int b = a + 1;
//}
さて、変数bの値はいくらでしょうか？@<br>{}
答えは@<b>{”不明”}です。@<br>{}
C++以降の言語だと aには"0"が格納されており、bは"1"と答えられる場合がほとんどですが、
C++は必ずしも aを"0"で初期化してくれる訳ではありません。従って、aの値が不明なので、bも不明です。
ちなみに、(以前の)Visual Studio C++のビルドでは、Debugモードだと初期値を格納してくれますが、Releaseモードでは初期値を設定してくれません。
cocos2d Xでも初期値を格納してくれません。（設定やバージョンによるかもしれませんが）
bool値も同様です。むしろ0以外のtrueが格納されているケースがほとんどです。
このことを知らず、初期値を設定しないコードを記載すると大きなバグを生み出します。
メンバの場合はコンストラクタで、ローカル変数の場合は生成時に必ず初期値を設定しましょう。@<br>{}
@<br>{}
@<br>{}
以上が基本となる知識となります。必ず覚えていてください。

=== ガベージコレクション(GC)について
現在の言語ではガベージコレクション(GC)と言う処理が存在します。
簡単に言うと”使われていないメモリを自動で解放してくれる仕組み”です。
冒頭で、new/deleteの事を記載しましたが、C/C++言語ではメモリの解放し忘れで大きな問題が発生していました。
また、ポインタの管理はソースコードが膨大になると非常に困難となります。
そこで生み出された仕組みがGCです。このことは頭の片隅にでも記憶していてください。@<br>{}
GCを理解していない方は基本的な部分だけでも調べておくと良いです。

=== C++11のスマートポインタについて
GCを理解した上で押さえておきたいものは、
C++11から追加されたスマートポインタがあります。
ポインタと言う名前が付いているのでポインタの一種です。
代表的なものを以下に示します。

・shared_ptr

・unique_ptr
@<br>{}
@<br>{}
それぞれの意味や用途は自身で調べてください。
ここで重要な事は"スマートポインタはGCされる"です。
並びに、C++11が登場し、C++言語にもGCの処理が追加されました。
これでポインタ管理、メモリ管理(delete)を行わなくて済みます。@<br>{}
しかし、注意して欲しい事は、deleteが必要となるポインタとスマートポインタが混在するソースコードです。
どれをdeleteして、どれを解放しなくても良いか？を常に考える必要があります。
また、deleteを理解していない方がソースコードを触ると、解放しないスマートポインタのコードを真似てしまい、後々大変なことになります。
従って、元来のポインタとスマートポインタが混在する場合はどちらかに統一する事をオススメします。
（元来のポインタをなくす事は大変だと思いますが、、、）

== その他
=== C++11/14について
C++言語は、C++11※の前と後のバージョンでは言語機能や標準ライブラリが大きく異なります。
自プロジェクトの環境のコンパイル環境がC++11に準拠しているかどうかをまず確認してください。
準拠していない場合は早めに対応することをオススメします。
C++11はC#を触ったことのある方にとっては、馴染みやすいと思います。@<br>{}

※ C++11は通称。2011年にISO/IEC 14882:2011として改定されたC++のバージョンのことを言います。

※ C++11以降でC++14(2014年にISO/IEC 14882:2014として改訂)がありますが、C++11ほどのインパクトはありません。

=== std::move()
C++11で登場した機能で、値渡しの問題点を解消する機能です。
値渡しでは、クラスの再生成が行われ、メモリも処理速度も浪費してしまいます。
std::move()を簡単に言うと、"コピー元のインスタンスを再利用"します。
使用上の注意点もありますので、細かい仕様はご自身で調べてください。
//cmd{
void functionE(int i, myClass myc) {
    ・・・
}

void functionZ() {
    myClass myc;
    myc.hour = 5;
    functionE(200, std::move(myc));
    ・・・
}
//}

=== マクロについて
C/C++言語ではマクロ定義が存在します。
マクロがどのようなものか？については、自身で勉強してください。
//cmd{
// オブジェクト形式マクロ
#define マクロ名 置換後の文字の並び

// 関数形式マクロ
#define マクロ名(引数のリスト) 置換後の文字の並び
//}
特に関数形式マクロは強力で使い方によっては非常に有効なものですが、開発環境によって使用できるものが異なります。
従って、よくわからないマクロが出てきた場合は、遠慮せず有識者に教わってください。@<br>{}
関数形式マクロの使用にはいくつもの落とし穴が存在します。
代表的なものとして、関数形式マクロのコード内ではデバッガーのブレイクポイントを貼っても、デバッグ実行でブレイク(停止)しないというものがあります。
従って、自プロジェクトだけで使用する様な関数形式マクロの新規作成は控えてください。
