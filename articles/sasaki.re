
﻿= 初心者でも何となくわかるSOLID解説
== はじめに
クラスを使ったプログラミング手法をオブジェクト指向プログラミング（OOP）と呼びます。
@<br>{}
このOOPはプログラミング技術の差が非常に出やすく、
初級プログラマがクラス設計を行うと「クラスを使わなかった方がマシだった」
とレビューされることも珍しくありません。
@<br>{}
よいクラス設計を理解していれば、非常に分かりやすいコードを書けるものですが、
学習する機会が少なくプログラミング経験〇年だけど「クラスを使っても分かりにくいコードは分かりにくい」と、
OOPをうまく扱えないまま経験だけを積み重ねる人もいるくらいです。
@<br>{}
SOLIDとはOOPの為の考え方です。
開発効率を大幅に上げ、システムの高い安全性（バグの発生しない設計）を確保するための設計指針です。
本稿では初心者でも分かるようにSOLIDの概念を要約する形で解説しているため、
厳密な説明は行っていませんが、なんとなく概要だけでも覚えてください。


== 単一責任の原則
==={単一責任の原則-目的} 目的
 * 将来起こりそうな修正や変更を予想する
 * 簡単に直せるように仕様単位でのクラス定義を目指す
==={単一責任の原則-概要} 概要
ソースコードはさまざまな要因で拡張変更が行われます。
特に業務で開発するコードは年単位で使用され何度も修正されるため、
開発初期段階で変更に強い設計をしているかどうかで、将来を含めた作業量は数倍の違いが出てきます。
@<b>{仕様単位でクラスを定義}してみましょう。
修正というものは仕様単位で依頼されるものなので、
コードも仕様単位でまとまっていると機能追加や修正が行いやすくなります。
===[column] 仕様という分け方
クラスを定義する時は、分類ではなく仕様で定義した方が、後々修正が簡単になります。
この分類か仕様かというのは結構微妙なところで、見る人によって仕様に見えたり分類に見えたりします。
HTMLとCSSってありますよね？
あれには単一責任の考えが含まれてまして、
表示される文字や図形は画面上で見ると１つの物体に見えます。
しかし内部ではHTMLに書かれた文字とCSSの装飾定義を画面上に表示する時に結合しています。
これは文章を変更する理由と装飾を変更する理由が大抵違うため、分かれていた方が都合がいいのです。
このように画面上１つの物体に見えるものでも、複数の仕様が結合していることがあります。
これを見極め分割するのが単一責任の目的です。
//image[solid_s01.png][solid_s01]{
//}
===[/column]


== 開放閉鎖原則
==={開放閉鎖原則-目的} 目的
 * 新機能追加はインターフェースの継承で対応する
==={開放閉鎖原則-概要} 概要
新しい機能を追加する時、既存のソースコードはできるだけ変更したくないものです。
だからといってif文などで既存コードを変更しないように新しいコードを追加すると、
大量の分岐と謎フラグと判定処理のオンパレードになり、
恐ろしく理解が難しいコードが生まれます（if文の分岐理由を読み解く作業は意外と重い）
新しい機能を追加したい時、
基底クラスやインターフェースを継承した継承クラスを追加するだけで機能追加が完了する、
そういった汎用性を目指すのが開放閉鎖原則です。
===[column] 分岐ではなくクラスメソッドを使う理由
たとえとして、温泉行きインターフェースを作り、
温泉行きインターフェースを継承した男性クラスと女性クラスを作ります。
インターフェース定義の中には温泉に向かうメソッドを定義し、
男性クラスは男湯、女性クラスは女湯に向かうように設定します。
実行すると男性クラスは必ず男湯に向かい、女性クラスは必ず女湯に向かうでしょう。
もしこれが人クラスで男女フラグを持っているだけなら、if文を使ってどっちに向かうか指示する必要があります。たかがif文１つです。しかし男性は必ず男湯、女性は必ず女湯だと確定している状況でうっかりif文を入れ忘れると、
意図しないバグが起こります。
クラスメソッドで"必ずこの行動を取る”と定義されていれば、
もっと複雑で大きなシステムであろうとif文付け忘れのような小さなミスは起こらなくなります。
クラスによって動作が確定している処理はそのクラス内に処理を書いた方が間違いが起こらないということです
//image[solid_o01.png][solid_o01]{
//}
===[/column]


== リスコフの置換原則
==={リスコフの置換原則-目的} 目的
 * ダウンキャストを使わない設計を目指す
//emlist[ダウンキャスト][c++]{
// ボス専用のクラスを定義
class BossCharacter : public Character;
    ～～～
// Characterをボスクラスにダウンキャスト出来たら、ボス戦用の動作を呼び出したい
BossCharacter xxx = (BossCharacter)character;
//}
==={リスコフの置換原則-概要} 概要
ダウンキャストをしなければいけない設計は、大抵例外的な処理を書くことになります。
Characterを継承したNpcCharacterという新しいクラスを作ったとき
BossCharacterをダウンキャストした箇所でXNpcCharacterもダウンキャストして独自の処理を呼ばなければバグる、
みたいな設計になってしまうことはよくあります。
これの問題は@<b>{知らなければバグる部分}が存在してしまうことです。
プロジェクトはどんどん人が入れ替わるので、
誰かに教えてもらわないと失敗しそうな設計をしないことが業務プログラマとして必要です。
その中でもダウンキャストはよく見かけるアンチパターンなので、
意識してダウンキャストが作られない設計を目指すべきです。
//emlist[やりすぎダウンキャスト][c++]{
if(auto boss = dynamic_cast<BossCharacter*>(*character)){
    // 専用処理
}else if(auto boss_supporter = dynamic_cast<BossSupportCharacter*>(*character)){
    // 専用処理
}else if(auto event_character = dynamic_cast<EventCharacter*>(*character)){
    // 専用処理
}else if(auto supporter = dynamic_cast<SupportCharacter*>(*character)){
    // 専用処理
}else if(auto dummy = dynamic_cast<DummyCharacter*>(*character)){
    // 専用処理
}
//}
※こういう処理が生み出されるのは珍しくない。
このようなコードがプロジェクトのさまざまな場所に登場するようになると、
新しいCharacter継承クラスを作った時の工数や検証は大掛かりなものになりやすい。
===[column] 知らなきゃ書けない
プログラミングにおいて知らなきゃ分からないコードは嫌われます。
「マジックナンバーや特殊な計算式」「名前として機能してない名前」
これらはコーディングされている場所において情報が隠匿されているのです。
隠匿されてるせいでコードを読み解くのが非常に難しくなります。
こういうものには情報を持った名前をきちんと付ける、もしくはコメントで補完する必要があります。
ちなみにダウンキャストはダウンキャストしなければいけない箇所が隠匿されることになり、
コメントでサポートしにくく、プロジェクト全体を検索しないと見つからないため、設計として嫌われます。
===[/column]

== インターフェース分離の原則
==={インターフェース分離の原則-目的} 目的
インターフェースメソッド（継承した時に必ず作らなきゃいけない）は最小限にする
==={インターフェース分離の原則-概要} 概要
「多機能であれば便利である」と考える人は多いんですが、
「テレビのリモコン」「使わないソフトがインストールされたパソコン」など、
良かれと思って増えた多機能は非常に使いにくいものです。
インターフェースを作る時は、絶対に必要なメソッドだけを定義することで、
「分かりにくい」を排除するすることができます。
===[column] インターフェース分離とリスコフ置換は相性が悪い
最小限の定義をもつインターフェースを作るというのはリスコフの置換原則と衝突することが多く、
最小限の機能にするとダウンキャストが欲しい、
ダウンキャストを避けると最小限の機能になっていない、
こんなことがよくあります。
大抵は最小限のつもりが多機能になっているので、
単一責任の考え方で機能分割を考えて、
単純なコード分割や依存性注入で問題解決を目指すことになります。
依存性注入とはクラスの中で必要になる処理をクラスの外で記述し渡してもらう方法です。
std::sortのようにソートする基礎ロジックは内部に持ってるけど、ソート条件は外からもらう、みたいな動きのことです。
===[/column]


== 依存性逆転の原則
==={依存性逆転の原則-目的} 目的
 * 全部インターフェースならバグなんて起こらない
==={依存性逆転の原則-概要} 概要
多用されるクラスは小さな修正でも、使用箇所すべてに影響を与える可能性があります。
そんなクラスも開放閉鎖原則を守った継承クラスだったら、
修正ではなく継承する形で機能を作ることで危険性を減らすことくらいはできるはずです。
開放閉鎖原則とかなり近いというか見ている目線が微妙に違うような定義です。
（※開放閉鎖は機能追加、リスコフはオブジェクト実行時、これは設計書）
@<br>{}
普通にコーディングをしたとき、
重複箇所や抜き出せそうな部分を関数やクラスにする手法がよく使われます。
この手法で作られたクラスは、
抜き出し元に強く依存する設計になりやすく、
結果として抜き出し元（上位レイヤー）が修正されたときに一緒に修正が必要になることが多いのです。
これを逆転させる。
@<b>{下位と上位の結合度を低く}。
上位レイヤーに変更されても下位レイヤーが一緒に変更されない。
これを実現するためにインターフェースを経由する処理の流れを作り、
下位と上位の依存を切り離すのが依存性逆転の目標になります。
===[column] 上位下位レイヤー
「よく他のクラスを呼び出すクラス」「よく他のクラスに呼び出されるクラス」
というのが存在しています。
Controllerという名前のクラスはいろんなクラスを呼び出している、
Viewは大抵controllerから呼び出されるけどcontrollerを呼び出すことはない。
このような呼び出しの流れを見たときに、呼び出し元ほど上位、呼び出され先ほど下位と呼びます。
===[/column]


== SOLID原則における雑記
SOLID原則は適応させることが出来ない部分、適応が非常に難しい部分が存在します。
@<br>{}
上位レイヤーや上位レイヤーに近い部分というものは、
小さな機能変更で大きな修正が発生しやすいため、
この部分にSOLID原則を適応するのはかなり難しいのです。
また上位レイヤーのどこかで継承クラスを呼び出す処理が必要になるので、
この部分だけはSOLIDに適応できません。
@<br>{}
SOLIDに適応させることが難しいと思う部分を無理に適応させると逆に複雑になる可能性が高いので、
慣れないうちは避けてしまった方がいいでしょう。
@<br>{}
このSOLIDというやつはライブラリのように明確に他人から呼ばれる機能を作るときに非常に有効なので、
そういう開発をするとき積極的に適応させると、
長期的に使っても問題が少ないコードが書けるようになると思います。
